use std::path::PathBuf;
use clap::Parser;
#[cfg(feature = "server")]
use figlet_rs::FIGfont;
#[cfg(feature = "server")]
use server::CambiaServer;
#[cfg(not(feature = "python"))]
use crate::util::parse_file;

#[cfg(feature = "server")]
mod server;
mod util;
mod consts;

/// Program to parse log files generated by various CD ripping software
#[derive(Parser, Clone, Debug)]
#[command(author, version, about, long_about = None)]
pub struct Args {
    /// Path to the log file, ignores server mode arguments if present
    #[arg(short, long)]
    path: Option<String>,
    /// Run the server and the web interface
    #[arg(short, long, env = "CAMBIA_SERVER")]
    #[cfg(feature = "server")]
    server: bool,
    /// Specify a port to listen on
    #[arg(long, env = "CAMBIA_PORT", value_parser = crate::server::port_in_range, default_value = crate::consts::DEFAULT_PORT)]
    #[cfg(feature = "server")]
    pub port: String,
    /// Set the log level
    #[arg(long, env = "CAMBIA_TRACING", default_value = "info")]
    pub tracing: String,
    /// Save the uploaded logs to a directory
    #[arg(long, env = "CAMBIA_SAVE_LOGS")]
    pub save_logs: Option<PathBuf>,
}

#[tokio::main]
pub async fn main() {
    let args = Args::parse();

    init_logging(&args.tracing);

    if args.save_logs.is_some() {
        tracing::info!("Log saving is enabled");
    }

    run(args).await;
}

#[cfg(all(feature = "server", not(feature = "python")))]
async fn run(args: Args) {
    if let Some(path) = args.path.clone() {
        parse_file(&path, args);
        return
    }

    let font = FIGfont::standard().unwrap();
    println!("{}", font.convert("cambia").unwrap());
    CambiaServer::new(args).start().await;
}

#[cfg(all(not(feature = "server"), not(feature = "python")))]
async fn run(args: Args) {
    let path = &args.path.clone().expect("Path not provided.");
    parse_file(path, args);
}

#[cfg(feature = "python")]
async fn run(_args: Args) {
    // When python feature is enabled, this is a library, not a binary
    // The main function should not be used
    panic!("This binary should not be run when python feature is enabled");
}

fn init_logging(tracing: &str) {
    let tracing_level = match tracing.to_ascii_lowercase().as_str() {
        "trace" => tracing::Level::TRACE,
        "debug" => tracing::Level::DEBUG,
        "warn" => tracing::Level::WARN,
        "error" => tracing::Level::ERROR,
        _ => tracing::Level::INFO,
    };

    tracing_subscriber::fmt()
        .with_max_level(tracing_level)
        .init();
}
